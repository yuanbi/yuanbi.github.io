<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="反调试总结"><meta name="keywords" content=""><meta name="author" content="BarretGuy"><meta name="copyright" content="BarretGuy"><title>反调试总结 | BasicBit</title><link rel="shortcut icon" href="/img/fav.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '6.0.0'
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#API-%E6%A3%80%E6%B5%8B"><span class="toc-number">1.</span> <span class="toc-text">API 检测</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PEB-BeingDebugged"><span class="toc-number">2.</span> <span class="toc-text">PEB BeingDebugged</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A0%A1%E9%AA%8C"><span class="toc-number">3.</span> <span class="toc-text">代码校验</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E4%BF%A1%E5%8F%B7%E5%88%A4%E6%96%AD"><span class="toc-number">4.</span> <span class="toc-text">调试信号判断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E9%81%8D%E5%8E%86"><span class="toc-number">5.</span> <span class="toc-text">窗口遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%88%B6%E8%BF%9B%E7%A8%8B%E5%88%A4%E6%96%AD"><span class="toc-number">6.</span> <span class="toc-text">父进程判断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FindWindow"><span class="toc-number">7.</span> <span class="toc-text">FindWindow</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9-amp-%E5%BC%82%E5%B8%B8"><span class="toc-number">8.</span> <span class="toc-text">硬件断点 &amp; 异常</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#INT-2D"><span class="toc-number">9.</span> <span class="toc-text">INT 2D</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NtGlobalFlag"><span class="toc-number">10.</span> <span class="toc-text">NtGlobalFlag</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NtQueryInformationProcess%E7%9A%84%E5%8F%A6%E5%A4%96%E4%B8%89%E7%A7%8D%E8%B0%83%E8%AF%95%E5%88%A4%E6%96%AD"><span class="toc-number">11.</span> <span class="toc-text">NtQueryInformationProcess的另外三种调试判断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NtQueryObject"><span class="toc-number">12.</span> <span class="toc-text">NtQueryObject</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NtQuerySystemInformation"><span class="toc-number">13.</span> <span class="toc-text">NtQuerySystemInformation</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ss%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">14.</span> <span class="toc-text">ss寄存器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E6%97%B6%E9%95%BF"><span class="toc-number">15.</span> <span class="toc-text">代码运行时长</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rdtsc%E6%8C%87%E4%BB%A4"><span class="toc-number">16.</span> <span class="toc-text">rdtsc指令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%9F%A5%E6%89%BE%E8%B0%83%E8%AF%95%E5%99%A8"><span class="toc-number">17.</span> <span class="toc-text">注册表查找调试器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rep%E6%8C%87%E4%BB%A4"><span class="toc-number">18.</span> <span class="toc-text">rep指令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E5%88%A4%E6%96%AD"><span class="toc-number">19.</span> <span class="toc-text">权限判断</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SEH%E5%BC%82%E5%B8%B81"><span class="toc-number">20.</span> <span class="toc-text">SEH异常1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SEH%E5%BC%82%E5%B8%B82"><span class="toc-number">21.</span> <span class="toc-text">SEH异常2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E6%AD%A5%E6%A3%80%E6%B5%8B"><span class="toc-number">22.</span> <span class="toc-text">单步检测</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StartInfo%E6%A3%80%E6%B5%8B"><span class="toc-number">23.</span> <span class="toc-text">StartInfo检测</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ZwSetInformationThread"><span class="toc-number">24.</span> <span class="toc-text">ZwSetInformationThread</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TLS%E5%8F%8D%E8%B0%83%E8%AF%95"><span class="toc-number">25.</span> <span class="toc-text">TLS反调试</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://file.qqtouxiang.com/qinglv/2020-07-10/968d1e73115194c7e70e2f729bb016b2.jpeg"></div><div class="author-info__name text-center">BarretGuy</div><div class="author-info__description text-center">不定期更新操作系统，编程，逆向，破解，算法等技术</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">45</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://imgset.gitee.io/img/1.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">BasicBit</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/Develop">Develop</a><a class="site-page" href="/Note">Note</a><a class="site-page" href="/Reverse">Reverse</a><a class="site-page" href="/OS">OS</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">反调试总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-11-30</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="API-检测"><a href="#API-检测" class="headerlink" title="API 检测"></a>API 检测</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PBYTE pCC = (PBYTE)MessageBoxW;</span><br><span class="line"><span class="keyword">if</span> (*pCC == <span class="number">0xCC</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">MessageBoxW(<span class="number">0</span>, <span class="string">L&quot;未发现调试器！\n&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在调试器中下断点时,会将目标地址的首字节替换为0xCC,上述代码以此进行判断会否处于调试状态</p>
<p>破解思路:避免在函数的首地址下断点,可以在函数的其他代码部分下断,通常在ret指令处下断</p>
<h1 id="PEB-BeingDebugged"><a href="#PEB-BeingDebugged" class="headerlink" title="PEB BeingDebugged"></a>PEB BeingDebugged</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__asm &#123;</span><br><span class="line">	MOV EAX, DWORD PTR FS : [0x30] ;获取PEB</span><br><span class="line">	MOV AL, BYTE PTR DS : [EAX + 2]</span><br><span class="line">	MOV bDebugged, AL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当进程被调试时,AL的值为1,这个值取自PEB的BeingDebugged成员.</p>
<h1 id="代码校验"><a href="#代码校验" class="headerlink" title="代码校验"></a>代码校验</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_Checksum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BOOL bDebugging = FALSE;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		call CHECKBEGIN</span><br><span class="line">CHECKBEGIN:</span><br><span class="line">		pop esi</span><br><span class="line">		mov ecx, <span class="number">0x15</span>           <span class="comment">// ecx : loop count</span></span><br><span class="line">		<span class="keyword">xor</span> eax, eax            <span class="comment">// eax : checksum</span></span><br><span class="line">		<span class="keyword">xor</span> ebx, ebx</span><br><span class="line"></span><br><span class="line">_CALC_CHECKSUM :</span><br><span class="line">		movzx ebx, byte ptr ds : [esi]</span><br><span class="line">		add eax, ebx</span><br><span class="line">		rol eax, <span class="number">1</span></span><br><span class="line">		inc esi</span><br><span class="line">		loop _CALC_CHECKSUM</span><br><span class="line">		cmp eax, <span class="number">0x1859a602</span></span><br><span class="line">		je _NOT_DEBUGGING</span><br><span class="line">		mov bDebugging, <span class="number">1</span></span><br><span class="line">_NOT_DEBUGGING:</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bDebugging;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="调试信号判断"><a href="#调试信号判断" class="headerlink" title="调试信号判断"></a>调试信号判断</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 尝试打开互斥体，确定是否首次运行程序</span></span><br><span class="line">	HANDLE hMutex = <span class="built_in">OpenMutex</span>(MUTEX_MODIFY_STATE, FALSE, <span class="string">L&quot;Global\\MyMutex&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (hMutex)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 打开成功说明第2次运行，执行正常代码</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;正被调试运行！\n&quot;</span>);</span><br><span class="line">		<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 打开失败说明第1次运行，创建互斥体，并调试创建自身进程</span></span><br><span class="line">		<span class="built_in">CreateMutex</span>(<span class="literal">NULL</span>, FALSE, <span class="string">L&quot;Global\\MyMutex&quot;</span>);</span><br><span class="line">		TCHAR szPath[MAX_PATH] = &#123;&#125;;</span><br><span class="line">		<span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, szPath, MAX_PATH);</span><br><span class="line">		<span class="comment">// 调试方式打开程序</span></span><br><span class="line">		STARTUPINFO si = &#123; <span class="built_in"><span class="keyword">sizeof</span></span>(STARTUPINFO) &#125;;</span><br><span class="line">		PROCESS_INFORMATION pi = &#123;&#125;;</span><br><span class="line">		<span class="comment">// 正常创建，后面附加调试</span></span><br><span class="line">		BOOL bStatus = <span class="built_in">CreateProcess</span>(szPath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE,</span><br><span class="line">			CREATE_NEW_CONSOLE,</span><br><span class="line">			<span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi);</span><br><span class="line">		<span class="keyword">if</span> (!bStatus) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;创建进程失败!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">DebugActiveProcess</span>(pi.dwProcessId)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;附加进程失败!\n&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 初始化调试事件结构体</span></span><br><span class="line">		DEBUG_EVENT DbgEvent = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		DWORD dwState = DBG_EXCEPTION_NOT_HANDLED;</span><br><span class="line">		<span class="comment">// 等待目标Exe产生调试事件</span></span><br><span class="line">		BOOL bExit = FALSE;</span><br><span class="line">		<span class="keyword">while</span> (!bExit) &#123;</span><br><span class="line">			<span class="built_in">WaitForDebugEvent</span>(&amp;DbgEvent, INFINITE);</span><br><span class="line">			<span class="keyword">if</span> (DbgEvent.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 被调试进程退出</span></span><br><span class="line">				bExit = TRUE;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">ContinueDebugEvent</span>(DbgEvent.dwProcessId, DbgEvent.dwThreadId, dwState);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以调试状态启动自身,等待调试事件触发,通过调试事件Code判断当前是否是调试状态,由于创建了互斥体,所以自身创建的调试进程启动后就退出了,不会出现两个软件同时运行的情况</p>
<p>破解思路: 跳转patch</p>
<h1 id="窗口遍历"><a href="#窗口遍历" class="headerlink" title="窗口遍历"></a>窗口遍历</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PROCESSENTRY32 pe32 = &#123; <span class="keyword">sizeof</span>(pe32) &#125;;</span><br><span class="line">HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 这里只比较了OllyDbg,也可以添加其他的调试分析工具名</span></span><br><span class="line">	<span class="keyword">if</span> (_tcsicmp(pe32.szExeFile, TEXT(<span class="string">&quot;OllyDbg.exe&quot;</span>)) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		CloseHandle(hProcessSnap);</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (Process32Next(hProcessSnap, &amp;pe32));</span><br><span class="line">CloseHandle(hProcessSnap);</span><br></pre></td></tr></table></figure>
<p>通过遍历当前所有的窗口列表,以此判断是否有进程名为调试器名字的软件</p>
<h1 id="父进程判断"><a href="#父进程判断" class="headerlink" title="父进程判断"></a>父进程判断</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PROCESS_BASIC_INFORMATION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DWORD ExitStatus;</span><br><span class="line">	DWORD PebBaseAddress;</span><br><span class="line">	DWORD AffinityMask;</span><br><span class="line">	DWORD BasePriority;</span><br><span class="line">	ULONG UniqueProcessId;</span><br><span class="line">	ULONG InheritedFromUniqueProcessId;</span><br><span class="line">&#125;pbi = &#123;&#125;;</span><br><span class="line">NtQueryInformationProcess(GetCurrentProcess(), ProcessBasicInformation, (PVOID)&amp;pbi, <span class="keyword">sizeof</span>(pbi), <span class="literal">NULL</span>);</span><br><span class="line">PROCESSENTRY32 pe32 = &#123; <span class="keyword">sizeof</span>(pe32) &#125;;</span><br><span class="line">HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pbi.InheritedFromUniqueProcessId == pe32.th32ProcessID)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (_tcsicmp(pe32.szExeFile, TEXT(<span class="string">&quot;explorer.exe&quot;</span>)) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			CloseHandle(hProcessSnap);</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			CloseHandle(hProcessSnap);</span><br><span class="line">			<span class="keyword">return</span> TRUE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (Process32Next(hProcessSnap, &amp;pe32));</span><br><span class="line">CloseHandle(hProcessSnap);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br></pre></td></tr></table></figure>



<p>NtQueryInformationProcess这个函数是未被公开的一个函数,在ntdll中,可以通过getprocaddress来调用,函数原型:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NTSTATUS WINAPI <span class="title">NtQueryInformationProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_      HANDLE           ProcessHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_      PROCESSINFOCLASS ProcessInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_     PVOID            ProcessInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_      ULONG            ProcessInformationLength,</span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_opt_ PULONG           ReturnLength</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>ProcessHandle:查询进程的句柄</p>
<p>ProcessInformationClass: 查找信息的标识符,可以取以下值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ProcessBasicInformation   0</span><br><span class="line">ProcessDebugPort          7 </span><br><span class="line">ProcessWow64Information      26</span><br><span class="line">ProcessImageFileName            27</span><br><span class="line">ProcessBreakOnTermination   29</span><br></pre></td></tr></table></figure>

<p>ProcessInformation：要存放查询结果的缓冲区，这个结构要根据第二个参数来决定，<br>ProcessInformationLength：缓冲区大小</p>
<p>ReturnLength：实际返回的写入缓冲区的字节数</p>
<p>当调用此函数,传入当前进程的句柄,参数2传入ProcessBasicInfomation,在参数3 就会返回PROCESS_BASIC_INFORMATION这个结构体,文中有定义,这个结构体中就包含了父进程的句柄,在通过遍历的方式判断父进程的名字是不是explorer即可</p>
<h1 id="FindWindow"><a href="#FindWindow" class="headerlink" title="FindWindow"></a>FindWindow</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_FindWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// OD的主窗口类名为 OLLYDBG，也可以查询其他调试器的类名</span></span><br><span class="line">	<span class="comment">// 其他常用调试器的类名可以使用Spy++查看</span></span><br><span class="line">	<span class="keyword">if</span> (FindWindow(TEXT(<span class="string">&quot;OLLYDBG&quot;</span>), <span class="literal">NULL</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL CALLBACK <span class="title">EnumWindowProc</span><span class="params">(HWND hWnd, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">	TCHAR winTitle[<span class="number">0x100</span>] = &#123;&#125;;</span><br><span class="line">	GetWindowText(hWnd, winTitle, <span class="number">0x100</span>);</span><br><span class="line">	<span class="keyword">if</span> (_tcsstr(winTitle, TEXT(<span class="string">&quot;OllyDbg&quot;</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// nFind=true</span></span><br><span class="line">		*((<span class="keyword">int</span>*)lParam) = <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">// 找到目标窗口停止遍历</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 继续遍历下一个窗口</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_EnumWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> nFind = <span class="literal">false</span>;</span><br><span class="line">	EnumWindows(EnumWindowProc, (LPARAM)&amp;nFind);</span><br><span class="line">	<span class="keyword">return</span> nFind != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个和之前的窗口遍历差不多,不过实现方式不同</p>
<h1 id="硬件断点-amp-异常"><a href="#硬件断点-amp-异常" class="headerlink" title="硬件断点 &amp; 异常"></a>硬件断点 &amp; 异常</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// API查询</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_HB</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CONTEXT context;</span><br><span class="line">	HANDLE hThread = GetCurrentThread();</span><br><span class="line">	context.ContextFlags = CONTEXT_DEBUG_REGISTERS;</span><br><span class="line">	GetThreadContext(hThread, &amp;context);</span><br><span class="line">	<span class="keyword">if</span> (context.Dr0 != <span class="number">0</span> || context.Dr1 != <span class="number">0</span> || context.Dr2 != <span class="number">0</span> || context.Dr3 != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发异常查询</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_HB_EXCEPTION</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BOOL bDebugging = FALSE;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		<span class="comment">// install SEH</span></span><br><span class="line">		push handler</span><br><span class="line">		push DWORD ptr fs : [<span class="number">0</span>]</span><br><span class="line">		mov DWORD ptr fs : [<span class="number">0</span>], esp</span><br><span class="line">		__emit(<span class="number">0xcc</span>)</span><br><span class="line">		mov bDebugging, <span class="number">1</span></span><br><span class="line">		jmp normal_code</span><br><span class="line">handler :</span><br><span class="line">		mov eax, dword ptr ss : [esp + <span class="number">0xc</span>];<span class="comment">// ContextRecord</span></span><br><span class="line">		mov dword ptr ds : [eax + <span class="number">0xb8</span>], offset normal_code;</span><br><span class="line">		mov ecx, [eax + <span class="number">4</span>];	<span class="comment">// Dr0</span></span><br><span class="line">		<span class="keyword">or</span> ecx, [eax + <span class="number">8</span>];	<span class="comment">// Dr1</span></span><br><span class="line">		<span class="keyword">or</span> ecx, [eax + <span class="number">0x0C</span>];<span class="comment">// Dr2</span></span><br><span class="line">		<span class="keyword">or</span> ecx, [eax + <span class="number">0x10</span>];<span class="comment">// Dr3</span></span><br><span class="line">		je NoDebugger;</span><br><span class="line">		mov ecx, [eax + <span class="number">0xb4</span>];<span class="comment">// ebp</span></span><br><span class="line">		<span class="comment">// vs2015 debug下bDebugging的地址为ebp-c</span></span><br><span class="line">		mov [ecx<span class="number">-0x0c</span>],<span class="number">1</span> <span class="comment">// bDebugging</span></span><br><span class="line">	NoDebugger:</span><br><span class="line">		<span class="keyword">xor</span> eax, eax</span><br><span class="line">		retn</span><br><span class="line">normal_code :</span><br><span class="line">		<span class="comment">//   remove SEH</span></span><br><span class="line">		pop dword ptr fs : [<span class="number">0</span>]</span><br><span class="line">		add esp, <span class="number">4</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bDebugging;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CheckDebug_HB函数,通过判断是否有硬件断点,如果有则为调试状态</p>
<p>CheckDebug_HB_EXCEPTION函数,设置SEH异常处理函数后触发异常,如果未在调试状态,则会走到自己的函数中,否则在调试状态下</p>
<h1 id="INT-2D"><a href="#INT-2D" class="headerlink" title="INT 2D"></a>INT 2D</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_INT_2D</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	BOOL bDebugging = FALSE;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		<span class="comment">// install SEH</span></span><br><span class="line">		push handler</span><br><span class="line">		push DWORD ptr fs : [<span class="number">0</span>]</span><br><span class="line">		mov DWORD ptr fs : [<span class="number">0</span>], esp</span><br><span class="line">		<span class="comment">// OD会忽略0x2d和nop，继续向后执行</span></span><br><span class="line">		<span class="comment">// 这时候可以选择只是检测调试器还是跑飞</span></span><br><span class="line">		<span class="keyword">int</span> <span class="number">0x2d</span></span><br><span class="line">		nop</span><br><span class="line">		mov bDebugging, <span class="number">1</span></span><br><span class="line">		jmp normal_code</span><br><span class="line">handler :</span><br><span class="line">		mov eax, dword ptr ss : [esp + <span class="number">0xc</span>]</span><br><span class="line">		mov dword ptr ds : [eax + <span class="number">0xb8</span>], offset normal_code</span><br><span class="line">		mov bDebugging, <span class="number">0</span></span><br><span class="line">		<span class="keyword">xor</span> eax, eax</span><br><span class="line">		retn</span><br><span class="line">normal_code :</span><br><span class="line">		<span class="comment">//   remove SEH</span></span><br><span class="line">		pop dword ptr fs : [<span class="number">0</span>]</span><br><span class="line">		add esp, <span class="number">4</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bDebugging;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法和CheckDebug_HB_EXCEPTION差不多,只不过触发异常的方式不同</p>
<h1 id="NtGlobalFlag"><a href="#NtGlobalFlag" class="headerlink" title="NtGlobalFlag"></a>NtGlobalFlag</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nNtFlag = <span class="number">0</span>;</span><br><span class="line">__asm &#123;</span><br><span class="line">	MOV EAX, DWORD PTR FS : [<span class="number">0x30</span>]</span><br><span class="line">	MOV EAX, DWORD PTR DS : [EAX + <span class="number">0x68</span>]</span><br><span class="line">	MOV nNtFlag, EAX</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nNtFlag==<span class="number">0x70</span>;</span><br></pre></td></tr></table></figure>

<p>在32位机器上, <code>NtGlobalFlag</code>字段位于<code>PEB</code>(进程环境块)<code>0x68</code>的偏移处, 64位机器则是在偏移<code>0xBC</code>位置. 该字段的默认值为0. 当调试器正在运行时, 该字段会被设置为一个特定的值:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FLG_HEAP_ENABLE_TAIL_CHECK (0x10)</span><br><span class="line">FLG_HEAP_ENABLE_FREE_CHECK (0x20)</span><br><span class="line">FLG_HEAP_VALIDATE_PARAMETERS (0x40)</span><br></pre></td></tr></table></figure>

<p>可以通过内存访问断点来定位反调试代码</p>
<p><strong>或者修改注册表,来替换GlobalFlag的值:</strong></p>
<p>注册表<code>HKLM\System\CurrentControlSet\Control\SessionManager</code>的<code>GlobalFlag</code>的值会替换进行<code>NtGlobalFlag</code>字段. 尽管它随后还可能由Windows改变(以下会介绍), 注册表键值会对系统中所有进程产生影响并在重启后生效.</p>
<h1 id="NtQueryInformationProcess的另外三种调试判断"><a href="#NtQueryInformationProcess的另外三种调试判断" class="headerlink" title="NtQueryInformationProcess的另外三种调试判断"></a>NtQueryInformationProcess的另外三种调试判断</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_DebugPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	DWORD dwDebugPort = <span class="number">0</span>;</span><br><span class="line">	NtQueryInformationProcess(GetCurrentProcess(), ProcessDebugPort, &amp;dwDebugPort, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> dwDebugPort == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_DebugHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	DWORD dwDebugHandle = <span class="number">0</span>;</span><br><span class="line">	NtQueryInformationProcess(GetCurrentProcess(), (PROCESSINFOCLASS)<span class="number">0x1E</span>, &amp;dwDebugHandle, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> dwDebugHandle != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法win7下已失效</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_DebugFlags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> bDebugFlags = <span class="number">0</span>;</span><br><span class="line">	NtQueryInformationProcess(GetCurrentProcess(), (PROCESSINFOCLASS)<span class="number">0x1F</span>, &amp;bDebugFlags, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, bDebugFlags);</span><br><span class="line">	<span class="keyword">return</span> bDebugFlags == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数二 = ProcessDebugPort </p>
<p>非调试状态下debugport == 0</p>
<p>参数二 = ProcessDebugObjectHandle</p>
<p>第三个参数返回为被调试对象句柄，当返回NULL时说明进程处于非调试状态</p>
<p>参数二 = ProcessDebugFlags</p>
<p>rocessDebugFlags参数用于获取调试标识，DebugFlag的值若为0则处于调试状态，若为1则处于非调试状态</p>
<h1 id="NtQueryObject"><a href="#NtQueryObject" class="headerlink" title="NtQueryObject"></a>NtQueryObject</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_QueryObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_TYPE_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		UNICODE_STRING TypeNames;</span><br><span class="line">		ULONG TotalNumberOfHandles;</span><br><span class="line">		ULONG TotalNumberOfObjects;</span><br><span class="line">	&#125;OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_ALL_INFORMATION</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ULONG NumberOfObjectsTypes;</span><br><span class="line">		OBJECT_TYPE_INFORMATION ObjectTypeInfo[<span class="number">1</span>];</span><br><span class="line">	&#125;OBJECT_ALL_INFORMATION, *POBJECT_ALL_INFORMATION;</span><br><span class="line">	<span class="comment">//1.获取欲查询信息大小</span></span><br><span class="line">	ULONG uSize = <span class="number">0</span>;</span><br><span class="line">	NtQueryObject(<span class="literal">NULL</span>, (OBJECT_INFORMATION_CLASS)<span class="number">0x03</span>, &amp;uSize, <span class="keyword">sizeof</span>(uSize), &amp;uSize);</span><br><span class="line">	<span class="comment">//2.获取对象大信息</span></span><br><span class="line">	POBJECT_ALL_INFORMATION pObjectAllInfo = (POBJECT_ALL_INFORMATION) <span class="keyword">new</span> BYTE[uSize+<span class="number">4</span>];</span><br><span class="line">	NtQueryObject(<span class="literal">NULL</span>, (OBJECT_INFORMATION_CLASS)<span class="number">0x03</span>, pObjectAllInfo, uSize, &amp;uSize);</span><br><span class="line">	<span class="comment">//3.循环遍历并处理对象信息</span></span><br><span class="line">	POBJECT_TYPE_INFORMATION pObjectTypeInfo = pObjectAllInfo-&gt;ObjectTypeInfo;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pObjectAllInfo-&gt;NumberOfObjectsTypes; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//3.1查看此对象的类型是否为DebugObject</span></span><br><span class="line">		<span class="keyword">if</span> (!wcscmp(<span class="string">L&quot;DebugObject&quot;</span>, pObjectTypeInfo-&gt;TypeNames.Buffer))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span>[] pObjectAllInfo;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3.2获取对象名占用空间大小(考虑到了结构体对齐问题)</span></span><br><span class="line">		ULONG uNameLength = pObjectTypeInfo-&gt;TypeNames.Length;</span><br><span class="line">		ULONG uDataLength = uNameLength - uNameLength % <span class="keyword">sizeof</span>(ULONG) + <span class="keyword">sizeof</span>(ULONG);</span><br><span class="line">		<span class="comment">//3.3指向下一个对象信息</span></span><br><span class="line">		pObjectTypeInfo = (POBJECT_TYPE_INFORMATION)pObjectTypeInfo-&gt;TypeNames.Buffer;</span><br><span class="line">		pObjectTypeInfo = (POBJECT_TYPE_INFORMATION)((PBYTE)pObjectTypeInfo + uDataLength);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] pObjectAllInfo;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>系统中某个调试器调试进程时，会创建一个调试对象类型的内核对象。检测该对象是否存在即可判断是否有进程正在被调试</p>
<p>ntdll!NtQueryObject可获得系统各种内核对象信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS NtQueryObject(</span><br><span class="line">  _In_opt_  HANDLE                   Handle,</span><br><span class="line">  _In_      OBJECT_INFORMATION_CLASS ObjectInformationClass,</span><br><span class="line">  _Out_opt_ PVOID                    ObjectInformation,</span><br><span class="line">  _In_      ULONG                    ObjectInformationLength,</span><br><span class="line">  _Out_opt_ PULONG                   ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>该API与上面讲过的API使用方法类似</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef enum _OBJECT_INFORMATION_CLASS &#123; </span><br><span class="line">  ObjectBasicInformation,</span><br><span class="line">  ObjectTypeInformation,</span><br><span class="line">  ObjectNameInformation,</span><br><span class="line">  ObjectAllInformation, //3</span><br><span class="line">  ObjectHandleInformation</span><br><span class="line">&#125; OBJECT_INFORMATION_CLASS;</span><br></pre></td></tr></table></figure>

<p>ObjectAllInformation(0x3)</p>
<p>使用ObjectAllInformation可获得系统所有对象信息，然后从中检测是否存在调试对象</p>
<h1 id="NtQuerySystemInformation"><a href="#NtQuerySystemInformation" class="headerlink" title="NtQuerySystemInformation"></a>NtQuerySystemInformation</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool CheckDebug_KernelDebug() &#123;</span><br><span class="line">	struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION</span><br><span class="line">	&#123;</span><br><span class="line">		BOOLEAN DebuggerEnabled;</span><br><span class="line">		BOOLEAN DebuggerNotPresent;</span><br><span class="line">	&#125;DebuggerInfo = &#123; 0 &#125;;</span><br><span class="line">	NtQuerySystemInformation(</span><br><span class="line">		(SYSTEM_INFORMATION_CLASS)0x23,		//查询信息类型</span><br><span class="line">		&amp;DebuggerInfo,						//输出查询信息</span><br><span class="line">		sizeof(DebuggerInfo),				//查询类型大小</span><br><span class="line">		NULL);								//实际返回数据大小</span><br><span class="line">	return DebuggerInfo.DebuggerEnabled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NtQuerySystemInformation这个函数用来获取当前的运行信息</p>
<p>当调用NtQuerySystemInfromation()API的时候，第一个参数SystemInformationClass的值被设置为systemKernelDebuggerInfromation(0x32的时候，函数调用返回的时候，若系统处于调试状态下，DebuggerEnable的值设置为1</p>
<h1 id="ss寄存器"><a href="#ss寄存器" class="headerlink" title="ss寄存器"></a>ss寄存器</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">    push ss</span><br><span class="line">    pop  ss</span><br><span class="line">    mov  eax, 0xC000C1EE // This line will be traced over by debugger</span><br><span class="line">    xor  edx, edx        // Debugger will step to this line</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用ss堆栈段寄存器进行操作时，调试器将跳过指令跟踪。如下图所示，调试器将立即移至xor edx，edx指令，同时执行上一条指令</p>
<h1 id="代码运行时长"><a href="#代码运行时长" class="headerlink" title="代码运行时长"></a>代码运行时长</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_QueryPerformanceCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LARGE_INTEGER startTime , endTime ;</span><br><span class="line">	QueryPerformanceCounter(&amp;startTime);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;我是核心代码\n也可以是核心代码前的反调试时间检测代码\n&quot;</span>);</span><br><span class="line">	QueryPerformanceCounter(&amp;endTime);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%llx\n&quot;</span>, endTime.QuadPart - startTime.QuadPart);</span><br><span class="line">	<span class="keyword">return</span> endTime.QuadPart - startTime.QuadPart &gt; <span class="number">0x500</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码运行时长检测不止这一种方法,像GetTickCount等函数都可以实现</p>
<h1 id="rdtsc指令"><a href="#rdtsc指令" class="headerlink" title="rdtsc指令"></a>rdtsc指令</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_RDTSC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int64_t</span> t1=<span class="number">0</span>, t2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> lo=<span class="number">0</span>, hi=<span class="number">0</span>;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		rdtsc</span><br><span class="line">		mov [lo], eax</span><br><span class="line">		mov [hi], edx</span><br><span class="line">	&#125;</span><br><span class="line">	t1 = ((<span class="keyword">int64_t</span>)lo) | ((<span class="keyword">int64_t</span>)hi &lt;&lt; <span class="number">32</span>);</span><br><span class="line">	__asm&#123;</span><br><span class="line">		rdtsc</span><br><span class="line">		mov[lo], eax</span><br><span class="line">		mov[hi], edx</span><br><span class="line">	&#125;</span><br><span class="line">	t2 = ((<span class="keyword">int64_t</span>)lo) | ((<span class="keyword">int64_t</span>)hi &lt;&lt; <span class="number">32</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;t2-t1=%llx\n&quot;</span>, t2 - t1);</span><br><span class="line">	<span class="comment">// 不同的CPU该差值不同，所以谨慎使用这种反调试方法</span></span><br><span class="line">	<span class="keyword">return</span> t2 - t1 &gt; <span class="number">0x100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法与代码运行时长类似</p>
<h1 id="注册表查找调试器"><a href="#注册表查找调试器" class="headerlink" title="注册表查找调试器"></a>注册表查找调试器</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_Registry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 判断当前系统是32还是64位</span></span><br><span class="line">	BOOL b64 = FALSE;</span><br><span class="line">	IsWow64Process(GetCurrentProcess(), &amp;b64);</span><br><span class="line">	HKEY hkey = <span class="literal">NULL</span>;</span><br><span class="line">	TCHAR *reg = b64 ?</span><br><span class="line">		TEXT(<span class="string">&quot;SOFTWARE\\Wow6432Node\\Microsoft\\WindowsNT\\CurrentVersion\\AeDebug&quot;</span>)</span><br><span class="line">		: TEXT(<span class="string">&quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug&quot;</span>);</span><br><span class="line">	<span class="comment">// 打开注册表键</span></span><br><span class="line">	DWORD ret = RegCreateKey(HKEY_LOCAL_MACHINE, reg, &amp;hkey);</span><br><span class="line">	<span class="keyword">if</span> (ret != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">	TCHAR *subkey = TEXT(<span class="string">&quot;Debugger&quot;</span>);</span><br><span class="line">	TCHAR value[<span class="number">256</span>] = &#123;&#125;;</span><br><span class="line">	DWORD len = <span class="number">256</span>;</span><br><span class="line">	<span class="comment">// 查询对应项的值</span></span><br><span class="line">	ret = RegQueryValueEx(hkey, subkey, <span class="literal">NULL</span>,<span class="literal">NULL</span>,(LPBYTE)value, &amp;len);</span><br><span class="line">	RegCloseKey(hkey);</span><br><span class="line">	<span class="comment">// 这里只查找了OD，也可以同时查找WinDbg,x64Dbg等常用调试器</span></span><br><span class="line">	<span class="keyword">if</span> (_tcsstr(value, TEXT(<span class="string">&quot;OLLYDBG&quot;</span>)) != <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过注册表查询是否包含调试器</p>
<h1 id="rep指令"><a href="#rep指令" class="headerlink" title="rep指令"></a>rep指令</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_CheckRepCC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	BOOL bDebugging = FALSE;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		<span class="keyword">xor</span> eax,eax</span><br><span class="line">		<span class="keyword">xor</span> ecx,ecx</span><br><span class="line">		inc ecx</span><br><span class="line">		lea esi,key</span><br><span class="line">		<span class="comment">// 此处步过时key处会被下0xCC断点</span></span><br><span class="line">		<span class="comment">// 将key处的首字节给AL</span></span><br><span class="line">		rep lodsb</span><br><span class="line">key:</span><br><span class="line">		cmp al,<span class="number">0xcc</span></span><br><span class="line">		je debuging</span><br><span class="line">		jmp over</span><br><span class="line">debuging:</span><br><span class="line">		mov bDebugging,<span class="number">1</span></span><br><span class="line">over :</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bDebugging;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行到rep指令时,key处地址会被下断,从而与0xCC判断,是否处于调试状态</p>
<h1 id="权限判断"><a href="#权限判断" class="headerlink" title="权限判断"></a>权限判断</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_SeDebugPrivilege</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取CsrGetProcessId函数地址</span></span><br><span class="line">	HMODULE hMod = GetModuleHandle(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*CSRGETPROCESSID)</span><span class="params">()</span></span>;</span><br><span class="line">	CSRGETPROCESSID CsrGetProcessId = (CSRGETPROCESSID)GetProcAddress(hMod, <span class="string">&quot;CsrGetProcessId&quot;</span>);</span><br><span class="line">	<span class="comment">// 获取csrss.exe的PID</span></span><br><span class="line">	DWORD pid = CsrGetProcessId();</span><br><span class="line">	<span class="comment">// 打开成功说明管理员+调试权限</span></span><br><span class="line">	HANDLE hCsr = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid);</span><br><span class="line">	<span class="keyword">if</span> (!hCsr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hCsr);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CheckDebug_EnumProcess_Csrss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD pid=<span class="number">0</span>;</span><br><span class="line">	DWORD ret = <span class="number">0</span>;</span><br><span class="line">	PROCESSENTRY32 pe32;</span><br><span class="line">	pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">	HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	Process32First(hProcessSnap, &amp;pe32);</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (wcscmp(pe32.szExeFile, <span class="string">L&quot;csrss.exe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			pid = pe32.th32ProcessID;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (Process32Next(hProcessSnap, &amp;pe32));</span><br><span class="line">	CloseHandle(hProcessSnap);</span><br><span class="line">	HANDLE hCss = OpenProcess(PROCESS_QUERY_INFORMATION, <span class="literal">NULL</span>, pid);</span><br><span class="line">	<span class="keyword">if</span> (!hCss)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hCss);</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述两个函数的实现不同,但作用是相同的,通过当前权限来判断是否处于调试状态</p>
<h1 id="SEH异常1"><a href="#SEH异常1" class="headerlink" title="SEH异常1"></a>SEH异常1</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_SEH</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	BOOL bDebugging = FALSE;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		<span class="comment">// install SEH</span></span><br><span class="line">		push handler</span><br><span class="line">		push DWORD ptr fs : [<span class="number">0</span>]</span><br><span class="line">		mov DWORD ptr fs : [<span class="number">0</span>], esp</span><br><span class="line">		__emit(<span class="number">0xcc</span>)</span><br><span class="line">		<span class="comment">// 只检测有无调试器</span></span><br><span class="line">		<span class="comment">// 若把mov bDebugging, 1改成__emit(0xE9)</span></span><br><span class="line">		<span class="comment">// 在调试器中就会跑飞</span></span><br><span class="line">		mov bDebugging, <span class="number">1</span></span><br><span class="line">		jmp normal_code</span><br><span class="line">handler :</span><br><span class="line">		mov eax, dword ptr ss : [esp + <span class="number">0xc</span>];<span class="comment">// ContextRecord</span></span><br><span class="line">		mov dword ptr ds : [eax + <span class="number">0xb8</span>], offset normal_code</span><br><span class="line">		<span class="keyword">xor</span> eax, eax</span><br><span class="line">		retn</span><br><span class="line">normal_code :</span><br><span class="line">		<span class="comment">//   remove SEH</span></span><br><span class="line">		pop dword ptr fs : [<span class="number">0</span>]</span><br><span class="line">		add esp, <span class="number">4</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bDebugging;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不在调试器中,则会走到代码中设置的的seh handler,否则将会继续执行</p>
<h1 id="SEH异常2"><a href="#SEH异常2" class="headerlink" title="SEH异常2"></a>SEH异常2</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LONG WINAPI <span class="title">Fun</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	_In_ struct _EXCEPTION_POINTERS *ExceptionInfo</span></span></span><br><span class="line"><span class="params"><span class="function">)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 跳过mov bDebug, 1这条指令</span></span><br><span class="line">	<span class="comment">// int 3异常时，eip会被回拨到cc处，所以要+5</span></span><br><span class="line">	ExceptionInfo-&gt;ContextRecord-&gt;Eip += <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_SetUnhandledExceptionFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> bDebug = <span class="literal">false</span>;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		__emit(<span class="number">0xCC</span>);</span><br><span class="line">		<span class="comment">// 正常运行时，Fun函数会跳过这条指令</span></span><br><span class="line">		<span class="comment">// 调试时，调试器会不停收到int 3异常，程序崩溃</span></span><br><span class="line">		mov bDebug, <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bDebug;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用CheckDebug_SetUnhandledExceptionFilter之前要先调用SetUnhandledExceptionFilter将Fun设置为SEH的handler,此方法与SEH异常处理1相似</p>
<h1 id="单步检测"><a href="#单步检测" class="headerlink" title="单步检测"></a>单步检测</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_SingleStep</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> bDebugged = <span class="literal">false</span>;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		<span class="comment">// install SEH</span></span><br><span class="line">		push handler</span><br><span class="line">		push DWORD ptr fs : [<span class="number">0</span>]</span><br><span class="line">		mov DWORD ptr fs : [<span class="number">0</span>], esp</span><br><span class="line">		pushfd</span><br><span class="line">		<span class="keyword">or</span> dword ptr ss : [esp], <span class="number">0x100</span></span><br><span class="line">		popfd</span><br><span class="line">		<span class="comment">// 被调试就继续执行</span></span><br><span class="line">		nop</span><br><span class="line">		mov bDebugged,<span class="number">1</span></span><br><span class="line">		jmp normal_code</span><br><span class="line">handler :</span><br><span class="line">		mov bDebugged, <span class="number">1</span></span><br><span class="line">		mov eax, dword ptr ss : [esp + <span class="number">0xc</span>]</span><br><span class="line">		mov ebx, normal_code</span><br><span class="line">		mov dword ptr ds : [eax + <span class="number">0xb8</span>], ebx</span><br><span class="line">		<span class="keyword">xor</span> eax, eax</span><br><span class="line">		retn</span><br><span class="line">normal_code :</span><br><span class="line">		<span class="comment">//   remove SEH</span></span><br><span class="line">		pop dword ptr fs : [<span class="number">0</span>]</span><br><span class="line">		add esp, <span class="number">4</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bDebugged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TF=1 的时候，会触发单步异常。该方法属于异常处理，不过比较特殊：未修改的 OD 无论<br>是 F9 还是 F8 都不能处理异常，有插件的 OD 在 F9 时能正确处理，F8 时不能正确处理。</p>
<h1 id="StartInfo检测"><a href="#StartInfo检测" class="headerlink" title="StartInfo检测"></a>StartInfo检测</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_STARTUPINFO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	STARTUPINFO si = &#123;&#125;;</span><br><span class="line">	GetStartupInfo(&amp;si);</span><br><span class="line">	<span class="keyword">if</span> (si.dwX || si.dwY || si.dwXSize || si.dwYSize)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%x %x %x %x\n&quot;</span>, si.dwX, si.dwY, si.dwXSize, si.dwYSize);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ZwSetInformationThread"><a href="#ZwSetInformationThread" class="headerlink" title="ZwSetInformationThread"></a>ZwSetInformationThread</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_SetInformationThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">THREAD_INFO_CLASS</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		ThreadHideFromDebugger = <span class="number">17</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI *ZW_SET_INFORMATION_THREAD)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">		IN HANDLE ThreadHandle,</span></span></span><br><span class="line"><span class="params"><span class="function">		IN THREAD_INFO_CLASS ThreadInformationClass,</span></span></span><br><span class="line"><span class="params"><span class="function">		IN PVOID ThreadInformation,</span></span></span><br><span class="line"><span class="params"><span class="function">		IN ULONG ThreadInformationLength)</span></span>;</span><br><span class="line">	ZW_SET_INFORMATION_THREAD ZwSetInformationThread;</span><br><span class="line">	ZwSetInformationThread = (ZW_SET_INFORMATION_THREAD)GetProcAddress(LoadLibrary(<span class="string">L&quot;ntdll.dll&quot;</span>), <span class="string">&quot;ZwSetInformationThread&quot;</span>);</span><br><span class="line">	ZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="function"><span class="keyword">bool</span> <span class="title">CheckDebug_STARTUPINFO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	STARTUPINFO si = &#123;&#125;;</span><br><span class="line">	GetStartupInfo(&amp;si);</span><br><span class="line">	<span class="keyword">if</span> (si.dwX || si.dwY || si.dwXSize || si.dwYSize)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%x %x %x %x\n&quot;</span>, si.dwX, si.dwY, si.dwXSize, si.dwYSize);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ZwSetInformationThread是一个未公开的函数,该API被调试者可将自身从调试器中分离出来（使调试进程终止运行，同时终止自身进程），该API不会对正常运行的程序(非调试运行)产生任何影响</p>
<h1 id="TLS反调试"><a href="#TLS反调试" class="headerlink" title="TLS反调试"></a>TLS反调试</h1><p>TLS相关知识:<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-249572.htm">https://bbs.pediy.com/thread-249572.htm</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/INCLUDE:__tls_used&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookupprocess</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Debugger</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> NTAPI <span class="title">tls_callback</span><span class="params">(PVOID h, DWORD reason, PVOID pv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        lookupprocess();</span><br><span class="line">        Debugger();</span><br><span class="line">        MessageBox(<span class="literal">NULL</span>,<span class="string">&quot;Not Main!&quot;</span>,<span class="string">&quot;Test1&quot;</span>,MB_OK);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建TLS段</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;.CRT$XLT&quot;</span>)</span></span><br><span class="line"><span class="comment">//定义回调函数</span></span><br><span class="line">PIMAGE_TLS_CALLBACK p_thread_callback = tls_callback;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义静态TLS全局变量</span></span><br><span class="line">__declspec(thread) <span class="keyword">int</span> value =<span class="number">0xcccccccc</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">NewThread</span> <span class="params">( LPVOID lParam )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置子线程value，并不影响其他线程</span></span><br><span class="line">    value = *((<span class="keyword">int</span>*)lParam);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,value);</span><br><span class="line">                Sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_NUM 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arry[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">// 设置主线程静态TLS的value为5</span></span><br><span class="line">    value = <span class="number">5</span> ;</span><br><span class="line">    <span class="comment">// 创建子线程</span></span><br><span class="line">    HANDLE hThread[THREAD_NUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> loop = <span class="number">0</span>; loop &lt; THREAD_NUM; loop++)</span><br><span class="line">    &#123;</span><br><span class="line">        hThread[loop] = CreateThread ( <span class="literal">NULL</span>, <span class="number">0</span>, NewThread, &amp;arry[loop], <span class="number">0</span>, <span class="literal">NULL</span> );</span><br><span class="line">                Sleep(<span class="number">20000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待直到子线程结束</span></span><br><span class="line">    WaitForMultipleObjects(THREAD_NUM, hThread, TRUE, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookupprocess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        PROCESSENTRY32 pe32;</span><br><span class="line">        pe32.dwSize = <span class="keyword">sizeof</span>(pe32);</span><br><span class="line">        HANDLE hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,<span class="number">0</span>);</span><br><span class="line">        BOOL bMore = ::Process32First(hProcessSnap,&amp;pe32);</span><br><span class="line">        <span class="keyword">while</span>(bMore)</span><br><span class="line">        &#123;</span><br><span class="line">                strlwr(pe32.szExeFile);</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(pe32.szExeFile,<span class="string">&quot;ollyice.exe&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(pe32.szExeFile,<span class="string">&quot;ollydbg.exe&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(pe32.szExeFile,<span class="string">&quot;peid.exe&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(pe32.szExeFile,<span class="string">&quot;idaq.exe&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                bMore = ::Process32Next(hProcessSnap,&amp;pe32);</span><br><span class="line">        &#125;</span><br><span class="line">        ::CloseHandle(hProcessSnap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//anti-debug2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Debugger</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        __asm</span><br><span class="line">        &#123;</span><br><span class="line">                mov     eax, dword ptr fs:[<span class="number">30</span>h]<span class="comment">//TEB偏移30H处</span></span><br><span class="line">                movzx   eax, byte ptr ds:[eax+<span class="number">2</span>h]<span class="comment">//取PEB中BeingDebug，若为1则被调试</span></span><br><span class="line">                mov result,eax</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">BarretGuy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://basicbit.cn/2018/11/30/2018-11-30-反调试总结/">https://basicbit.cn/2018/11/30/2018-11-30-反调试总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/12/20/2018-12-20-Python%E5%8F%8D%E7%BC%96%E8%AF%91%EF%BC%9F%E5%85%88%E8%81%8A%E8%81%8Apyc%E7%BB%93%E6%9E%84%E5%90%A7/"><i class="fa fa-chevron-left">  </i><span>python  pyc文件结构</span></a></div><div class="next-post pull-right"><a href="/2018/11/20/2018-11-19-%E7%BD%91%E6%98%93%E6%B8%B8%E6%88%8F%E8%BE%85%E5%8A%A9%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"><span>网易xx游戏辅助的心路历程</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://imgset.gitee.io/img/1.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2022 By BarretGuy</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>